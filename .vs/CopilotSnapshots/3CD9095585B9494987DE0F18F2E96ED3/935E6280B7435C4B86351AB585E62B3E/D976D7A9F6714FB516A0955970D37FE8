#include "glut.h"
#include <vector>
#include <string>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <ctime>
#include <map> // Needed for contingency checks

#include "Definitions.h"
#include "Grid.h"
#include "Units.h"
#include "Renderer.h"
#include "SecurityMap.h"
#include "Visibility.h"
#include "Combat.h"
#include "Pathfinding.h"
#include "Globals.h"
#include "Warrior.h" // Specific unit types might be needed

// AI Includes
#include "Orders.h"
#include "AIEvents.h"
#include "EventBus.h"
#include "Commander.h"
#include "StateMachine.h"

using namespace Definitions;

// -----------------------------------------------------------------------------
// World state
// -----------------------------------------------------------------------------
Models::Grid              g_grid;
std::vector<Models::Unit> g_units;
Simulation::SecurityMap   g_smap;
static AI::Visibility::BArray g_vis;

// View modes
static bool g_showSecurity = false; // Right-click
static bool g_showVisibility = false; // 'V'
static Team g_visTeam = Team::Blue; // 'C'

// HUD (to console)
static float g_fps = 0.0f;
static long  g_cntRock = 0, g_cntTree = 0, g_cntWater = 0, g_cntDepot = 0;
static int   g_blueCount = 0, g_orangeCount = 0;

// Combat + target cell
Combat::System g_combat;
static int g_targetRow = -1, g_targetCol = -1;

// Debug: shooter highlight (fades by frame count)
static int g_shooterRow = -1, g_shooterCol = -1;
static int g_shooterHighlightFrames = 0;

// Pathfinding debug/drive
static AI::Pathfinding::Path g_path;
static bool  g_pathIsAStar = false;
static float g_astarRiskWeight = 3.0f;

// Path-following (manual drive with 'P')
static bool g_moveActive = false;
static int  g_movePathIdx = 0;
static int  g_moveUnitIdx = -1;
static int  g_moveDelayFrames = 6;
static int  g_moveFrameCounter = 0;

// Commander + helpers (two commanders—blue and orange)
static AI::Commander g_commanderBlue(Definitions::Team::Blue);
static AI::Commander g_commanderOrange(Definitions::Team::Orange);
static std::vector<Models::Unit*> g_teamBluePtrs;
static std::vector<Models::Unit*> g_teamOrangePtrs;
static int  g_frameCounter = 0;
static bool g_commanderEnabled = false; // OFF by default

// Random spawn flags/ids (debug)
static bool g_randomizeWarriorsSpawn = true;
static int  g_randBlueWarriorId = -1;
static int  g_randOrangeWarriorId = -1;

// Anchors
static bool g_blueAnchorValid = false;
static bool g_orangeAnchorValid = false;
static int  g_orangeAnchorR = -1, g_orangeAnchorC = -1;


// -----------------------------------------------------------------------------
// Helpers
// -----------------------------------------------------------------------------

static void computeMapCounts()
{
    g_cntRock = g_cntTree = g_cntWater = g_cntDepot = 0;
    for (int r = 0; r < GRID_SIZE; ++r)
        for (int c = 0; c < GRID_SIZE; ++c) {
            int v = g_grid.at(r, c);
            if (v == ROCK)               ++g_cntRock;
            else if (v == TREE)          ++g_cntTree;
            else if (v == WATER)         ++g_cntWater;
            else if (v == DEPOT_AMMO || v == DEPOT_MED) ++g_cntDepot;
        }
}

static void computeUnitCounts()
{
    g_blueCount = g_orangeCount = 0;
    for (const auto& u : g_units) {
        if (!u.isAlive) continue;
        if (u.team == Team::Blue) ++g_blueCount; else ++g_orangeCount;
    }
}

static void rebuildVisibility()
{
    if (!g_showVisibility) { AI::Visibility::Clear(g_vis); return; }
    AI::Visibility::BuildTeamVisibility(g_grid, g_units, g_visTeam, SIGHT_RANGE, g_vis);
}

static void clearPathAndMovement()
{
    g_path.clear();
    g_moveActive = false;
    g_movePathIdx = 0;
    g_moveUnitIdx = -1;
    g_moveFrameCounter = 0;
}

// Follow debug path (manual)
static void followPathStep()
{
    if (!g_moveActive) return;
    if (g_moveUnitIdx < 0 || g_moveUnitIdx >= (int)g_units.size()) { g_moveActive = false; return; }
    auto& u = g_units[g_moveUnitIdx];
    if (!u.isAlive) { g_moveActive = false; return; }
    if (g_path.empty()) { g_moveActive = false; return; }
    if (g_movePathIdx < 0 || g_movePathIdx >= (int)g_path.size()) { g_moveActive = false; return; }

    // If already at the target waypoint, advance to the next one
    if (u.row == g_path[g_movePathIdx].first && u.col == g_path[g_movePathIdx].second) {
        ++g_movePathIdx;
        if (g_movePathIdx >= (int)g_path.size()) { g_moveActive = false; return; }
    }

    // Check bounds again after potential index increment
    if (g_movePathIdx >= (int)g_path.size()) { g_moveActive = false; return; }

    int wr = g_path[g_movePathIdx].first;
    int wc = g_path[g_movePathIdx].second;

    if (!AI::Pathfinding::IsWalkableForMovement(g_grid.at(wr, wc))) { g_moveActive = false; return; } // Path blocked
    if (AI::Pathfinding::IsOccupied(wr, wc)) return; // Cell occupied, wait

    // Move the unit
    u.row = wr;
    u.col = wc;

    // Advance path index for next step
    ++g_movePathIdx;
    if (g_movePathIdx >= (int)g_path.size()) g_moveActive = false; // Reached end
}

// ======= Overlay helpers (HUD/Markers) =======
static void drawTargetCross()
{
    if (g_targetRow < 0 || g_targetCol < 0) return;
    const float x = g_targetCol * CELL_PX + CELL_PX * 0.5f;
    const float y = g_targetRow * CELL_PX + CELL_PX * 0.5f;
    const float half = CELL_PX * 0.45f;

    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_COLOR_BUFFER_BIT);
    glDisable(GL_TEXTURE_2D);
    glDisable(GL_DEPTH_TEST);
    glLineWidth(2.f);

    glColor3f(1.f, 0.f, 1.f); // Magenta cross
    glBegin(GL_LINES);
    glVertex2f(x - half, y); glVertex2f(x + half, y);
    glVertex2f(x, y - half); glVertex2f(x, y + half);
    glEnd();

    glPopAttrib();
}

static void drawShooterHighlight()
{
    if (g_shooterHighlightFrames <= 0 || g_shooterRow < 0 || g_shooterCol < 0) return;

    const float x = g_shooterCol * CELL_PX + CELL_PX * 0.5f;
    const float y = g_shooterRow * CELL_PX + CELL_PX * 0.5f;
    const float rad = CELL_PX * 0.45f;

    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_COLOR_BUFFER_BIT);
    glDisable(GL_TEXTURE_2D);
    glDisable(GL_DEPTH_TEST);
    glLineWidth(2.f);

    glColor3f(1.f, 0.6f, 0.f); // Orange circle
    glBegin(GL_LINE_LOOP);
    for (int i = 0; i < 32; ++i) {
        float a = (2.f * 3.14159265f) * (i / 32.f);
        glVertex2f(x + rad * std::cos(a), y + rad * std::sin(a));
    }
    glEnd();

    glPopAttrib();
}

static void drawPathOverlay()
{
    if (g_path.empty()) return;

    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_COLOR_BUFFER_BIT | GL_POINT_BIT);
    glDisable(GL_TEXTURE_2D);
    glDisable(GL_DEPTH_TEST);
    glLineWidth(3.f);

    glColor3f(0.0f, 0.9f, 0.9f); // Cyan path
    glBegin(GL_LINE_STRIP);
    for (const auto& cell : g_path) {
        float x = (cell.second + 0.5f) * CELL_PX;
        float y = (cell.first + 0.5f) * CELL_PX;
        glVertex2f(x, y);
    }
    glEnd();

    // Mark the end point
    if (!g_path.empty()) {
        const auto& last = g_path.back();
        float gx = (last.second + 0.5f) * CELL_PX;
        float gy = (last.first + 0.5f) * CELL_PX;
        glPointSize(6.f);
        glBegin(GL_POINTS);
        glVertex2f(gx, gy);
        glEnd();
    }

    glPopAttrib();
}

// Colored ring around each unit's letter
static void drawTeamRings()
{
    const float GLYPH_W_FACTOR = 0.42f; // Estimated width factor of the character glyph
    const float GLYPH_H_FACTOR = 0.55f; // Estimated height factor
    const float MARGIN_PX = 2.5f;       // Space between glyph and ring

    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_COLOR_BUFFER_BIT);
    glDisable(GL_TEXTURE_2D);
    glDisable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glLineWidth(1.0f);

    auto drawRing = [](float x, float y, float rad) {
        glBegin(GL_LINE_LOOP);
        for (int i = 0; i < 48; ++i) { // More segments for smoother circle
            float a = (2.f * 3.14159265f) * (i / 48.f);
            glVertex2f(x + rad * std::cos(a), y + rad * std::sin(a));
        }
        glEnd();
        };

    for (const auto& u : g_units) {
        if (!u.isAlive) continue;
        const float cx = u.col * CELL_PX + CELL_PX * 0.5f;
        const float cy = u.row * CELL_PX + CELL_PX * 0.5f;
        // Estimate glyph bounding box radius
        const float halfW = (CELL_PX * GLYPH_W_FACTOR) * 0.5f;
        const float halfH = (CELL_PX * GLYPH_H_FACTOR) * 0.5f;
        const float glyphHalfDiag = std::sqrt(halfW * halfW + halfH * halfH);
        const float rad = glyphHalfDiag + MARGIN_PX;
        // Set color based on team
        if (u.team == Team::Blue) glColor4f(0.20f, 0.60f, 1.00f, 0.95f); // Blue
        else                      glColor4f(1.00f, 0.55f, 0.10f, 0.95f); // Orange
        drawRing(cx, cy, rad);
    }

    glPopAttrib();
}


static void DebugOverlayDraw()
{
    drawTargetCross();
    drawShooterHighlight();
    drawPathOverlay();
    drawTeamRings();
    g_combat.draw(); // bullets + grenades
}

// -----------------------------------------------------------------------------
// Random & anchors respecting playfield
// -----------------------------------------------------------------------------
static inline bool inHalf(Definitions::Team t, int c) {
    return (t == Definitions::Team::Blue) ? (c < GRID_SIZE / 2) : (c >= GRID_SIZE / 2);
}

static bool isSpawnableCell(int r, int c)
{
    if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE) return false;
    if (!AI::Pathfinding::inPlayfield(r, c)) return false; // Must be in playable area
    if (!AI::Pathfinding::IsWalkableForMovement(g_grid.at(r, c))) return false; // Must be walkable terrain
    if (AI::Pathfinding::IsOccupied(r, c)) return false; // Must not be occupied
    return true;
}

static bool randomFreeCellInHalf(Definitions::Team team, int& outR, int& outC)
{
    const int tries = 500;
    for (int k = 0; k < tries; ++k) {
        int r = std::rand() % GRID_SIZE;
        int c = std::rand() % GRID_SIZE;
        if (!AI::Pathfinding::inPlayfield(r, c)) continue;
        if (!inHalf(team, c)) continue; // Must be in the correct half
        if (!AI::Pathfinding::IsWalkableForMovement(g_grid.at(r, c))) continue;
        if (AI::Pathfinding::IsOccupied(r, c)) continue;
        outR = r; outC = c;
        return true;
    }
    return false; // Failed to find a spot after many tries
}

static void randomizeAllWarriorsInTeams()
{
    if (!g_randomizeWarriorsSpawn) return;
    g_randBlueWarriorId = -1;
    g_randOrangeWarriorId = -1;

    for (auto& u : g_units) {
        if (!u.isAlive || u.role != Role::Warrior) continue;
        int r, c;
        if (randomFreeCellInHalf(u.team, r, c)) {
            u.row = r; u.col = c; u.isMoving = false;
            // Track one random warrior per team (for debugging maybe?)
            if (u.team == Team::Blue && g_randBlueWarriorId == -1)   g_randBlueWarriorId = u.id;
            if (u.team == Team::Orange && g_randOrangeWarriorId == -1) g_randOrangeWarriorId = u.id;
        }
    }
}

static bool selectAnchorForTeam(Definitions::Team team, int& outR, int& outC)
{
    const int tries = AI::Commander::ANCHOR_RETRIES;
    const float safeMax = AI::Commander::SAFE_RISK_MAX;

    int bestR = -1, bestC = -1; float bestRisk = 1e9f;

    // Try to find a SAFE spot
    for (int k = 0; k < tries; ++k) {
        int r = std::rand() % GRID_SIZE;
        int c = std::rand() % GRID_SIZE;
        if (!isSpawnableCell(r, c)) continue; // Use helper
        if (!inHalf(team, c)) continue;

        float risk = g_smap.at(r, c);
        if (risk <= safeMax && risk < bestRisk) {
            bestRisk = risk; bestR = r; bestC = c;
            if (bestRisk <= 0.05f) break; // Good enough, stop early
        }
    }
    // Fallback: If no SAFE spot found, find the LEAST DANGEROUS spot
    if (bestR < 0) {
        for (int k = 0; k < tries; ++k) {
            int r = std::rand() % GRID_SIZE;
            int c = std::rand() % GRID_SIZE;
            if (!isSpawnableCell(r, c)) continue;
            if (!inHalf(team, c)) continue;
            float risk = g_smap.at(r, c);
            if (risk < bestRisk) { bestRisk = risk; bestR = r; bestC = c; }
        }
    }
    if (bestR >= 0) { outR = bestR; outC = bestC; return true; }
    return false; // Very unlikely, means no valid spots found
}

// Place the first unit of a given role/team at (r, c) if possible
static void placeFirstByRole(Definitions::Team team, Definitions::Role role, int r, int c)
{
    for (auto& u : g_units) {
        if (!u.isAlive) continue;
        if (u.team == team && u.role == role) {
            if (!AI::Pathfinding::IsOccupied(r, c)) { // Only place if the spot is free
                u.row = r; u.col = c; u.isMoving = false;
            }
            break; // Found the first one, stop
        }
    }
}

static void placeBlueCommanderAtAnchorIfAvailable()
{
    if (g_commanderBlue.anchorR < 0 || g_commanderBlue.anchorC < 0) return; // No valid anchor
    placeFirstByRole(Team::Blue, Role::Commander, g_commanderBlue.anchorR, g_commanderBlue.anchorC);
}

static void commanderSafetyMonitorStep()
{
    // Lambda function to get risk at a cell
    auto riskAt = [&](int r, int c)->float { return g_smap.at(r, c); };
    // Check if blue commander needs to move
    if (g_commanderBlue.safetyMonitor(riskAt, g_frameCounter, g_grid)) {
        placeBlueCommanderAtAnchorIfAvailable(); // Move if a new anchor was selected
    }
    // TODO: Add same logic for orange commander if needed
}

static void sanitizeWorldOutsidePlayfield()
{
    const int EMPTY_CELL = Definitions::Cell::EMPTY;
    for (int r = 0; r < GRID_SIZE; ++r) {
        for (int c = 0; c < GRID_SIZE; ++c) {
            if (AI::Pathfinding::inPlayfield(r, c)) continue; // Skip cells inside play area
            // Clear obstacles outside play area
            int v = g_grid.at(r, c);
            if (v == ROCK || v == TREE || v == DEPOT_AMMO || v == DEPOT_MED || v == WATER) {
                g_grid.set(r, c, EMPTY_CELL);
            }
        }
    }
}

// -----------------------------------------------------------------------------
// Auto Enemy Sightings (simple, with cooldown)
// -----------------------------------------------------------------------------
static void autoEnemySightings(int frameCounter)
{
    // Spam prevention: report only every ~15 frames
    if (frameCounter % 15 != 0) return;

    auto reportLOS = [&](Definitions::Team /*myTeam*/, // myTeam not used, Event contains sender ID
        const std::vector<Models::Unit*>& mine,
        const std::vector<Models::Unit*>& theirs)
        {
            for (auto* me : mine) {
                if (!me || !me->isAlive) continue;
                // Find first enemy with Line Of Sight within sight range
                for (auto* en : theirs) {
                    if (!en || !en->isAlive) continue;
                    int dr = en->row - me->row;
                    int dc = en->col - me->col;
                    if (dr * dr + dc * dc > SIGHT_RANGE * SIGHT_RANGE) continue; // Out of range
                    if (!AI::Visibility::HasLineOfSight(g_grid, me->row, me->col, en->row, en->col)) continue; // Blocked

                    // Report (from=me->id, to=-1 for broadcast)
                    AI::EventBus::instance().publish(AI::Message{
                        AI::EventType::EnemySighted,
                        /*from*/ me->id,
                        /*to*/   -1,
                        /*row*/  en->row,
                        /*col*/  en->col,
                        /*extra*/0
                        });
                    break; // This unit already reported, move to next friendly unit
                }
            }
        };

    reportLOS(Definitions::Team::Blue, g_teamBluePtrs, g_teamOrangePtrs);
    reportLOS(Definitions::Team::Orange, g_teamOrangePtrs, g_teamBluePtrs);
}


// -----------------------------------------------------------------------------
// Build world
// -----------------------------------------------------------------------------
static void buildTestWorld()
{
    g_grid = Models::Grid(); // Creates grid with obstacles/depots
    sanitizeWorldOutsidePlayfield(); // Clean up edges

    // ----- Blue lineup -----
    const int rowBlue = GRID_SIZE / 6;
    const int startBlue = GRID_SIZE / 10;
    const int step = 3;

    g_units.clear();
    g_units.reserve(10); // Reserve space for 10 units (5 blue, 5 orange)
    g_units.emplace_back(Team::Blue, Role::Commander, rowBlue, startBlue + step * 0);
    g_units.emplace_back(Team::Blue, Role::Warrior, rowBlue, startBlue + step * 1);
    g_units.emplace_back(Team::Blue, Role::Medic, rowBlue, startBlue + step * 2);
    g_units.emplace_back(Team::Blue, Role::Supplier, rowBlue, startBlue + step * 3);
    g_units.emplace_back(Team::Blue, Role::Warrior, rowBlue, startBlue + step * 4);

    // ----- Orange lineup -----
    const int rowOrange = GRID_SIZE - GRID_SIZE / 6;
    const int startOrange = GRID_SIZE - GRID_SIZE / 10;
    g_units.emplace_back(Team::Orange, Role::Commander, rowOrange, startOrange - step * 0);
    g_units.emplace_back(Team::Orange, Role::Warrior, rowOrange, startOrange - step * 1);
    g_units.emplace_back(Team::Orange, Role::Medic, rowOrange, startOrange - step * 2);
    g_units.emplace_back(Team::Orange, Role::Supplier, rowOrange, startOrange - step * 3);
    g_units.emplace_back(Team::Orange, Role::Warrior, rowOrange, startOrange - step * 4);

    // ----- Assign IDs and build pointer vectors -----
    int nextUnitId = 1;
    g_teamBluePtrs.clear();
    g_teamOrangePtrs.clear();
    for (auto& u : g_units) {
        u.id = nextUnitId++;
        u.isMoving = false;
        u.isFighting = false; // Initialize flags
        u.isAutonomous = false;
        u.isAlive = true;     // Make sure units start alive
        // Populate team pointer vectors and link commanders
        if (u.team == Team::Blue) {
            g_teamBluePtrs.push_back(&u);
            if (u.role == Role::Commander) g_commanderBlue.setUnitId(u.id);
        }
        else {
            g_teamOrangePtrs.push_back(&u);
            if (u.role == Role::Commander) g_commanderOrange.setUnitId(u.id);
        }
    }

    // ----- Final setup -----
    randomizeAllWarriorsInTeams(); // Optional random placement
    computeMapCounts();
    computeUnitCounts();
    g_smap.RebuildSecurityMap(g_grid);
    rebuildVisibility();

    // ----- Set initial anchors -----
    int ar, ac;
    g_blueAnchorValid = false;
    g_orangeAnchorValid = false;
    // Blue anchor
    if (selectAnchorForTeam(Team::Blue, ar, ac)) {
        placeFirstByRole(Team::Blue, Role::Commander, ar, ac); // Move commander to anchor
        g_commanderBlue.anchorR = ar; g_commanderBlue.anchorC = ac;
        g_blueAnchorValid = true;
    }
    // Orange anchor
    if (selectAnchorForTeam(Team::Orange, ar, ac)) {
        placeFirstByRole(Team::Orange, Role::Commander, ar, ac);
        g_commanderOrange.anchorR = ar; g_commanderOrange.anchorC = ac; // Store orange anchor too
        g_orangeAnchorValid = true;
    }

    // ----- Reset UI/Debug state -----
    g_targetRow = g_targetCol = -1;
    g_shooterRow = g_shooterCol = -1;
    g_shooterHighlightFrames = 0;
    clearPathAndMovement();
    g_commanderEnabled = false; // Start with AI off
    g_frameCounter = 0;

    // ----- Link combat system -----
    g_combat.bindUnits(&g_units);
    g_combat.friendlyFire = false;

    // ----- Subscribe commanders to events -----
    g_commanderBlue.initSubscriptions();
    g_commanderOrange.initSubscriptions();
}

// -----------------------------------------------------------------------------
// Display / Idle / Input
// -----------------------------------------------------------------------------
static void display()
{
    // FPS calculation
    static int frames = 0, t0 = 0;
    int t = glutGet(GLUT_ELAPSED_TIME);
    frames++;
    if (t - t0 >= 500) { // Update FPS roughly twice per second
        g_fps = frames * 1000.0f / float(t - t0);
        t0 = t; frames = 0;
    }

    // Build HUD strings
    char buf1[200], buf2[128], buf3[128], buf4[160], buf7[128], bufCmd[64];
    std::snprintf(buf1, sizeof(buf1),
        "FPS: %.1f  Grid: %dx%d Cell: %dpx Security:%s(RClk) Visibility:%s(V, team=%s)",
        g_fps, GRID_SIZE, GRID_SIZE, CELL_PX,
        g_showSecurity ? "ON" : "OFF",
        g_showVisibility ? "ON" : "OFF",
        (g_visTeam == Team::Blue ? "Blue" : "Orange"));
    std::snprintf(buf2, sizeof(buf2), "Cells ROCK:%ld TREE:%ld WATER:%ld DEPOTS:%ld",
        g_cntRock, g_cntTree, g_cntWater, g_cntDepot);
    std::snprintf(buf3, sizeof(buf3), "Units BLUE:%d ORANGE:%d", g_blueCount, g_orangeCount);
    std::snprintf(buf4, sizeof(buf4), "SMap max=%.2f samples=%d decay=%.3f",
        g_smap.maxValue(), SECURITY_SAMPLES, SECURITY_DECAY);
    std::snprintf(bufCmd, sizeof(bufCmd), "Commander: %s (K)", g_commanderEnabled ? "ON" : "OFF");

    std::vector<std::string> hud; hud.reserve(16);
    hud.push_back(buf1); hud.push_back(buf2); hud.push_back(buf3); hud.push_back(buf4);
    hud.push_back(bufCmd);

    if (!g_path.empty()) {
        char buf6[96];
        std::snprintf(buf6, sizeof(buf6), "Path: %s, len=%d",
            (g_pathIsAStar ? "A*(risk)" : "BFS"), (int)g_path.size());
        hud.push_back(buf6);
    }
    std::snprintf(buf7, sizeof(buf7), "Move: %s idx=%d unit=%d speed=%d(f/s)",
        (g_moveActive ? "ON" : "OFF"), g_movePathIdx, g_moveUnitIdx, g_moveDelayFrames);
    hud.push_back(buf7);

    // Print HUD to console occasionally
    static int lastPrintMs = 0;
    int nowMs = glutGet(GLUT_ELAPSED_TIME);
    if (nowMs - lastPrintMs > 1000) {
        printf("\n--- Frame %d ---\n", g_frameCounter);
        for (const auto& s : hud) std::printf("%s\n", s.c_str());
        fflush(stdout);
        lastPrintMs = nowMs;
    }

    // Select render mode and draw
    if (g_showVisibility)
        Painting::RenderFrameWithVisibility_Overlay(g_grid, g_units, g_vis, hud, &DebugOverlayDraw);
    else if (g_showSecurity)
        Painting::RenderFrameWithSecurity_Overlay(g_grid, g_units, g_smap, hud, &DebugOverlayDraw);
    else
        Painting::RenderFrameWithHUD_Overlay(g_grid, g_units, hud, &DebugOverlayDraw); // Standard view
}


static void idle()
{
    // --- Contingency Checks ---
    struct TeamStatus { /* ... */ }; // As defined before
    std::map<Team, TeamStatus> teamStatus;
    // Tally counts... (as before)
    for (auto& u : g_units) { /* ... */ }

    // Apply contingency rules per team... (as before)
    for (auto const& [team, status] : teamStatus) {
        std::vector<Models::Unit*>& teamPtrs = (team == Team::Blue) ? g_teamBluePtrs : g_teamOrangePtrs;

        if (!status.commanderAlive && status.warriorsAlive) {
            // Rule 1: Commander dead -> Warriors autonomous
            bool changed = false;
            for (auto* u : teamPtrs) {
                if (u && u->isAlive && u->role == Role::Warrior && !u->isAutonomous) {
                    u->isAutonomous = true;
                    changed = true;
                }
            }
            if (changed) printf("[CONTINGENCY/%s] Commander down! Warriors autonomous.\n", teamTag(team));

        }
        else if (!status.warriorsAlive && status.commanderAlive) {
            // Rule 2: Warriors dead -> Commander fights
            if (status.commander && !status.commander->isFighting) {
                printf("[CONTINGENCY/%s] Warriors down! Commander fights.\n", teamTag(team));
                status.commander->isFighting = true;
            }
        }
        else if (!status.warriorsAlive && !status.commanderAlive && status.supportsAlive) {
            // Rule 3: Everyone dead -> Supports fight
            bool changed = false;
            for (auto* u : teamPtrs) {
                if (u && u->isAlive && (u->role == Role::Medic || u->role == Role::Supplier) && !u->isFighting) {
                    u->isFighting = true;
                    changed = true;
                }
            }
            if (changed) printf("[CONTINGENCY/%s] All combat units down! Supports fight.\n", teamTag(team));
        }
    }
    // --- End of Contingency Checks ---

    // 1) Physics/Risk
    g_combat.tickBullets(g_grid, g_smap); // Update bullets, apply damage
    commanderSafetyMonitorStep();         // Check if commander needs new anchor

    // 2) Commander Tick (Skipped if commander isFighting)
    if (g_commanderEnabled) {
        autoEnemySightings(g_frameCounter); // Basic AI sighting reports
        g_commanderBlue.tick(g_grid, g_teamBluePtrs, g_teamOrangePtrs, g_frameCounter);
        g_commanderOrange.tick(g_grid, g_teamOrangePtrs, g_teamBluePtrs, g_frameCounter);
    }

    // 3) Unit Update Loop (FSM + Warrior Reports)
    for (auto& u : g_units) {
        if (u.isAlive && u.m_fsm) {
            u.m_fsm->Update(); // Update unit's state machine
        }
        // Warrior reporting (conditional on !isAutonomous is inside the function now)
        if (u.isAlive && u.role == Definitions::Role::Warrior) {
            Models::Warrior& warrior = static_cast<Models::Warrior&>(u);
            warrior.CheckAndReportStatus();
        }
        // TODO: Could add similar CheckAndReportStatus for Medic/Supplier if they need autonomous reporting
    }

    // 4) Manual Path Following (for debugging)
    if (g_moveActive) {
        ++g_moveFrameCounter;
        if (g_moveFrameCounter >= g_moveDelayFrames) {
            g_moveFrameCounter = 0;
            followPathStep();
        }
    }

    // 5) Recount Living Units (for HUD)
    computeUnitCounts();

    // 6) Final Updates & Redisplay
    if (g_shooterHighlightFrames > 0) --g_shooterHighlightFrames; // Fade highlight
    ++g_frameCounter;
    glutPostRedisplay(); // Request redraw
}


static void mouse(int button, int state, int x, int y)
{
    if (state != GLUT_DOWN) return; // Only react on button press

    if (button == GLUT_RIGHT_BUTTON) {
        g_showSecurity = !g_showSecurity;
        if (g_showSecurity) g_showVisibility = false; // Security map overrides visibility
        rebuildVisibility(); // Update visibility overlay if needed
        return;
    }

    if (button == GLUT_LEFT_BUTTON) {
        // Convert screen coordinates (x, y) to grid cell (row, col)
        int winW = glutGet(GLUT_WINDOW_WIDTH);
        int winH = glutGet(GLUT_WINDOW_HEIGHT);
        if (winW <= 0 || winH <= 0) return;

        float fx = (float)x / (float)winW;
        float fy = (float)y / (float)winH;

        int col = (int)std::floor(fx * GRID_SIZE);
        int row = (int)std::floor((1.0f - fy) * GRID_SIZE); // Y is inverted

        // Clamp to grid bounds
        if (col < 0) col = 0; else if (col >= GRID_SIZE) col = GRID_SIZE - 1;
        if (row < 0) row = 0; else if (row >= GRID_SIZE) row = GRID_SIZE - 1;

        g_targetCol = col; // Set the global target cell
        g_targetRow = row;
        printf("Target set to (%d, %d)\n", row, col);
    }
}

static void keyboard(unsigned char key, int /*x*/, int /*y*/)
{
    switch (key) {
        // --- View Modes ---
    case 'v': case 'V': // Toggle Visibility map
        g_showVisibility = !g_showVisibility;
        if (g_showVisibility) g_showSecurity = false;
        rebuildVisibility();
        break;
    case 'c': case 'C': // Change Visibility team
        g_visTeam = (g_visTeam == Team::Blue ? Team::Orange : Team::Blue);
        rebuildVisibility();
        break;
    case 'r': case 'R': // Rebuild Security map
        g_smap.RebuildSecurityMap(g_grid);
        break;

        // --- Combat Debug ---
    case 'f': case 'F': { // Fire bullet from nearest blue warrior to target
        if (g_targetRow < 0) break; // No target selected
        int bestIdx = -1; float bestD2 = 1e18f;
        // Find nearest blue warrior
        for (int i = 0; i < (int)g_units.size(); ++i) { /* ... find nearest ... */ }
        if (bestIdx >= 0) {
            const auto& w = g_units[bestIdx];
            g_shooterRow = w.row; g_shooterCol = w.col; g_shooterHighlightFrames = 30; // Highlight shooter
            g_combat.fireBulletTowards((float)w.row, (float)w.col, (float)g_targetRow, (float)g_targetCol, Team::Blue);
        }
    } break;
    case 'g': case 'G': { // Drop grenade at target (or self if no target)
        int bestIdx = -1; float bestD2 = 1e18f;
        // Find nearest blue warrior
        for (int i = 0; i < (int)g_units.size(); ++i) { /* ... find nearest ... */ }
        if (bestIdx >= 0) {
            const auto& w = g_units[bestIdx];
            g_shooterRow = w.row; g_shooterCol = w.col; g_shooterHighlightFrames = 30;
            if (g_targetRow >= 0) g_combat.dropGrenade((float)g_targetRow, (float)g_targetCol, g_grid, Team::Blue);
            else                  g_combat.dropGrenade((float)w.row, (float)w.col, g_grid, Team::Blue); // Drop at self
        }
    } break;
    case 'm': case 'M': { // Throw grenade from nearest blue warrior to target
        if (g_targetRow < 0) break; // Need target
        int bestIdx = -1; float bestD2 = 1e18f;
        // Find nearest blue warrior
        for (int i = 0; i < (int)g_units.size(); ++i) { /* ... find nearest ... */ }
        if (bestIdx >= 0) {
            const auto& w = g_units[bestIdx];
            g_shooterRow = w.row; g_shooterCol = w.col; g_shooterHighlightFrames = 30;
            g_combat.throwGrenadeParabola((float)w.row, (float)w.col, (float)g_targetRow, (float)g_targetCol, Team::Blue);
        }
    } break;

            // --- Pathfinding Debug ---
    case 'b': case 'B': { // Calculate BFS path from nearest blue unit to target
        if (g_targetRow < 0) break;
        clearPathAndMovement();
        int bestIdx = -1; float bestD2 = 1e18f;
        // Find nearest blue unit (any role)
        for (int i = 0; i < (int)g_units.size(); ++i) { /* ... find nearest ... */ }
        if (bestIdx >= 0) {
            const auto& s = g_units[bestIdx];
            g_path = AI::Pathfinding::BFS_FindPath(g_grid, { s.row,s.col }, { g_targetRow,g_targetCol });
            g_pathIsAStar = false;
            g_moveUnitIdx = bestIdx; // Set unit for 'P' key
            g_movePathIdx = 0;
            printf("BFS path calculated (len=%zu)\n", g_path.size());
        }
    } break;
    case 'a': case 'A': { // Calculate A* path from nearest blue unit to target
        if (g_targetRow < 0) break;
        clearPathAndMovement();
        int bestIdx = -1; float bestD2 = 1e18f;
        // Find nearest blue unit
        for (int i = 0; i < (int)g_units.size(); ++i) { /* ... find nearest ... */ }
        if (bestIdx >= 0) {
            const auto& s = g_units[bestIdx];
            g_path = AI::Pathfinding::AStar_FindPath(g_grid, g_smap, { s.row,s.col }, { g_targetRow,g_targetCol }, g_astarRiskWeight);
            g_pathIsAStar = true;
            g_moveUnitIdx = bestIdx;
            g_movePathIdx = 0;
            printf("A* path calculated (len=%zu)\n", g_path.size());
        }
    } break;
    case 'p': case 'P': { // Toggle path following for the selected unit
        if (g_path.empty() || g_moveUnitIdx < 0 || g_moveUnitIdx >= (int)g_units.size()) {
            g_moveActive = false; break;
        }
        auto& u = g_units[g_moveUnitIdx];
        // Ensure path starts at unit's current location (fix if unit moved)
        if (!g_path.empty() && (g_path.front().first != u.row || g_path.front().second != u.col)) {
            AI::Pathfinding::Path fixedPath;
            fixedPath.push_back({ u.row, u.col }); // Start from current pos
            // Find where the unit is *on* or *closest to* the original path
            // Simple approach: just append the rest of the original path. A better way
            // would be to recalculate or find the nearest point on the path.
            // For now, let's just use the original path, skipping the first point.
            if (g_path.size() > 1) {
                fixedPath.insert(fixedPath.end(), g_path.begin() + 1, g_path.end());
            }
            g_path.swap(fixedPath);
        }

        g_movePathIdx = (g_path.size() > 1) ? 1 : 0; // Start moving towards the first step
        g_moveFrameCounter = 0;
        g_moveActive = !g_moveActive; // Toggle movement
        printf("Path following %s\n", g_moveActive ? "ON" : "OFF");
    } break;
    case 'x': case 'X': // Clear current path
        clearPathAndMovement();
        printf("Path cleared.\n");
        break;

        // --- AI Control ---
    case 'k': case 'K': // Toggle Commander AI
        g_commanderEnabled = !g_commanderEnabled;
        printf("Commander AI %s\n", g_commanderEnabled ? "ENABLED" : "DISABLED");
        break;

        // --- Manual Events ---
    case '1': { // Simulate EnemySighted event at target
        if (g_targetRow >= 0) {
            printf("Simulating EnemySighted at (%d,%d)\n", g_targetRow, g_targetCol);
            AI::Message m{ AI::EventType::EnemySighted, /*from*/0, /*to*/-1, g_targetRow, g_targetCol, 0 };
            AI::EventBus::instance().publish(m);
        }
    } break;

    default: break; // Ignore other keys
    }
}


static void reshape(int w, int h)
{
    if (h == 0) h = 1; // Prevent divide by zero
    glViewport(0, 0, w, h);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    const int worldW = GRID_SIZE * CELL_PX;
    const int worldH = GRID_SIZE * CELL_PX;
    glOrtho(0.0, (double)worldW, 0.0, (double)worldH, -1.0, 1.0); // Orthographic projection matching world size

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

// -----------------------------------------------------------------------------
// Main
// -----------------------------------------------------------------------------
int main(int argc, char** argv)
{
    std::srand((unsigned)std::time(nullptr)); // Seed random number generator

    buildTestWorld(); // Initialize grid, units, etc.

    // Init GLUT
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE); // Double buffered, RGB color

    const int W = GRID_SIZE * CELL_PX; // Window width
    const int H = GRID_SIZE * CELL_PX; // Window height
    glutInitWindowSize(W, H);
    glutInitWindowPosition(100, 50); // Initial window position
    glutCreateWindow("Tactical AI Simulation"); // Window title

    Painting::RenderInit(W, H); // Initialize renderer
    Painting::SetHudEnabled(false); // Disable built-in HUD, we print to console

    // Register callbacks
    glutDisplayFunc(display);       // Drawing function
    glutIdleFunc(idle);             // Background processing function
    glutMouseFunc(mouse);           // Mouse button handler
    glutKeyboardFunc(keyboard);       // Keyboard key handler
    glutReshapeFunc(reshape);       // Window resize handler

    // Start the main loop
    glutMainLoop();
    return 0;
}